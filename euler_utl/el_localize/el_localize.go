package el_localize

import (
	"errors"
	"strconv"
	"strings"
)

type Localize struct {
	text_key    string
	lang        string
	problemnum  int
	map_of_text map[string]string
}

var map_of_text map[string]string
var err error

func lang_exist(lang string) error {
	languages := map[string]int{"EN": 1, "DE": 2}
	_, ok := languages[strings.ToUpper(lang)]

	if !ok {
		return errors.New("Language  " + lang + " not exists")
	} else {
		return nil
	}

}

func New(problemnum int, lang string) (*Localize, error) {

	map_of_text := make(map[string]string)

	init_localize(map_of_text)
	err := lang_exist(lang)

	return &Localize{
		problemnum:  problemnum,
		lang:        strings.ToUpper(lang),
		text_key:    strconv.Itoa(problemnum) + "_" + strings.ToUpper(lang),
		map_of_text: map_of_text}, err
}

func init_localize(map_of_text map[string]string) {
	//----------------------------- Problem 1 -------------------------------------------------------------------------------------------
	map_of_text["1_EN"] = `If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. 
The sum of these multiples is 23.

Find the sum of all the multiples of 3 or 5 below 1000.`
	map_of_text["1_DE"] = `Wenn wir alle natürlichen Zahlen unter 10 auflisten, die Vielfache von 3 oder 5 sind, 
so erhalten wir 3, 5, 6 und 9. Die Summe dieser Vielfachen ist 23.

Finden Sie die Summe aller Vielfachen von 3 oder 5 unter 1000.`

	//----------------------------- Problem 2 -------------------------------------------------------------------------------------------
	map_of_text["2_EN"] = `Each new term in the Fibonacci sequence is generated by adding the previous two terms. 
By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, 
find the sum of the even-valued terms.`
	map_of_text["2_DE"] = `Jeder neue Term in der Fibonacci-Reihe wird gebildet, indem die beiden vorherigen Zahlen addiert werden. 
Wenn man mit 1 und 2 beginnt, sind die ersten 10 Terme wie folgt:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

Finden Sie die Summe aller geraden Terme der Fibonacci-Reihe, die 4 Millionen nicht überschreiten.`

	//----------------------------- Problem 3 -------------------------------------------------------------------------------------------
	map_of_text["3_EN"] = `The prime factors of 13195 are 5, 7, 13 and 29.

What is the largest prime factor of the number 600851475143 ?`
	map_of_text["3_DE"] = `Die Primfaktoren von 13195 sind 5, 7, 13 und 29.

Was ist der größte Primfaktor der Zahl 600851475143?`

	//----------------------------- Problem 4 -------------------------------------------------------------------------------------------
	map_of_text["4_EN"] = `A palindromic number reads the same both ways. 
The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.

Find the largest palindrome made from the product of two 3-digit numbers.`
	map_of_text["4_DE"] = `Eine Palindromzahl liest sich rückwärts so wie vorwärts. 
Das größte Palindrom, das ein Produkt von 2 zweistelligen Zahlen ist, ist 9009 = 91 × 99.

Finden Sie das größte Palindrom, das das Produkt von 2 dreistelligen Zahlen ist.`
	//----------------------------- Problem 5 -------------------------------------------------------------------------------------------
	map_of_text["5_EN"] = `2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.

What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?`
	map_of_text["5_DE"] = `2520 ist die kleinste Zahl, die ohne Rest durch jede Zahl von 1 bis 10 teilbar ist.

Was ist die kleinste positive Zahl, die durch alle Zahlen von 1 bis 20 glatt teilbar ist?`
	//----------------------------- Result Line -------------------------------------------------------------------------------------------
	map_of_text["R_EN"] = "Result of the problem %d is %d"
	map_of_text["R_DE"] = "Ergebnis des Problems %d ist %d"
}

func (t *Localize) Get_result_txt() string {
	//text := t.map_of_text["R_"+t.lang]
	return t.map_of_text["R_"+t.lang]
}

func (t *Localize) Get_problem_text() string {
	return t.map_of_text[t.text_key]
}
